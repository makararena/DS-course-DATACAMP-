sns.swarmplot(x='state', y='dem_share', data=df_swing) # используем swarmplot,который показывает количество точек и их распределение,главное 
# чтобы это все не было в огромных масштабах

ECDF - # распределение(лучше всего показать на картинке,поэтому оно будет в папке)

# То,как сделать ECDF с помощью данных
x = np.sort(df_swing['dem_share']) # сортируем колонку
y = np.arange(1, len(x)+1) / len(x) #numpy.arange() — это встроенная в библиотеку NumPy функция, которая возвращает объект типа ndarray,
#содержащий равномерно расположенные значения внутри заданного интервала.
#Например, чтобы сгенерировать значения от одного до десяти, вы можете воспользоваться функцией numpy.arange(). 

np.meadian()#Медиа́на (от лат. mediāna «середина») или серединное значение набора чисел — число,
#которое находится в середине этого набора, если его упорядочить по возрастанию, то есть такое число, что половина из элементов набора не меньше него, а другая половина не больше.

np.mean()#среднее значение 

np.percentile(df_swing['dem_share'], [25, 50, 75])#Перцентиль - это показатель, используемый в статистике,
#показывающий значение, ниже которого падает определенный процент наблюдений в группе наблюдений
# например 25-й процетиль показывает те значения,которые меньше 25% всех значений

IQR - # — число, которое показывает разброс средней половины (т.е. средние 50%) набора данных и помогает определить выбросы

np.var() # вычисляет дисперсию значений элементов массива.
#Мера разброса значений случайной величины относительно её математического ожидания

np.sqrt() # показывает корень

np.std() # среднеквадрати́ческое (среднеквадрати́чное) отклоне́ние — наиболее распространённый показатель рассеивания значений случайной величины 
#относительно её математического ожидания (аналога среднего арифметического с бесконечным числом исходов). Обычно он означает квадратный корень из дисперсии случайной величины


np.random.random(size = 4):#draw a random number between 0 and 1    4 раза 

np.random.binomial(4, 0.5, size=10) # биноминальное распределение(от 0 до 4-x,вероятность - 50%,количество цифр - 10)

samples = np.random.binomial(60, 0.1, size=10000) # биноминальное распределение для PDF
n = 60
p = 0.1

# биноминальное распределение для CDF 
samples = np.random.binomial(60, 0.1, size=10000)
n = 60
p = 0.1
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()
x, y = ecdf(samples)
_ = plt.plot(x, y, marker='.', linestyle='none')
plt.margins(0.02)
_ = plt.xlabel('number of successes')
_ = plt.ylabel('CDF')plt.show()


# Распределение Пуассона для CDF 
samples = np.random.poisson(6, size=10000)
x, y = ecdf(samples)
_ = plt.plot(x, y, marker='.', linestyle='none')
plt.margins(0.02)
_ = plt.xlabel('number of successes')
_ = plt.ylabel('CDF')plt.show()



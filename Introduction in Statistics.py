# Дисперсия, в знаменатиле N-1
np.var(msleep['sleep_total'], ddof=1)

# Просто дисперсия 
np.var(msleep['sleep_total'])

# Среднеквадратическое отклонение через дисперсию и корень 
np.sqrt(np.var(msleep['sleep_total'], ddof=1))

# Просто среднеквадратическое отклонение 
np.std(msleep['sleep_total'], ddof=1)

# Среднее абсолютное отклонение(им никто не пользуется,но оно существует),плохо работает с выбросами 
dists = msleep['sleep_total'] - mean(msleep$sleep_total)
np.mean(np.abs(dists))

# Считаем квантили 
np.quantile(msleep['sleep_total'], [0, 0.25, 0.5, 0.75, 1])

# Так работает np.linspace,num - количество 
np.linspace(start, stop, num)

# Так тоже можно считать квантили 
np.quantile(msleep['sleep_total'], np.linspace(0, 1, 5))

# Считаем IQR(75 квантиль - 25 квантиль )
np.quantile(msleep['sleep_total'], 0.75) - np.quantile(msleep['sleep_total'], 0.25)

# Импорт и использование IQR 
from scipy.stats import iqr
iqr(msleep['sleep_total'])


# Считаем выбросы(обычно выбросы - это 25-й процентиль - 1,5 * IQR,или же 75-й процентиль + 1,5 * IQR )
from scipy.stats import iqr
iqr = iqr(msleep['bodywt'])
lower_threshold = np.quantile(msleep['bodywt'], 0.25) - 1.5 * iqr
upper_threshold = np.quantile(msleep['bodywt'], 0.75) + 1.5 * iqr
msleep[(msleep['bodywt'] < lower_threshold) | (msleep['bodywt'] > upper_threshold)]     # Выбираем все выбросы 

------------------------------------------------------------------------------------------------------------------------------------------------------
# Выбираем случайную колонку sales_count,с помощью sample 
sales_counts.sample()

# Берем 5 любых строчек(могут попасться 2 одинаковые)
sales_counts.sample(5, replace = True)


# Мат.ожидание сумма всех шансов на их значения 

# Центра́льные преде́льные теоре́мы (ЦПТ) — класс теорем в теории вероятностей, утверждающих, что сумма достаточно большого 
# количества слабо зависимых случайных величин, имеющих примерно одинаковые масштабы (ни одно из слагаемых не доминирует, 
# не вносит в сумму определяющего вклада), имеет распределение, близкое к нормальному.

---------------------------
# Шанс того,что автобус приедет с 0 по 7-ю минуту при существующих 12-ти 
from scipy.stats import uniform
uniform.cdf(7, 0, 12)

# От 7-й,до 12-й
from scipy.stats import uniform
1 - uniform.cdf(7, 0, 12)

# От 4-й,до 7-й
from scipy.stats import uniform
uniform.cdf(7, 0, 12) - uniform.cdf(4, 0, 12)

# Cоздаем 10 рандомных значений от 0 до 5,медиана будет примерно 2,5; Не нормальное распределение 
from scipy.stats import uniform
uniform.rvs(0, 5, size=10)
-----------------------------
# Если uniform используеться со временем,то биноминальное распределение обычно используеться для бинарных величин(успех/не успех)
# Дословно : 'брось 1 монету с шансом выпадания 50%, 1 раз'
from scipy.stats import binom
binom.rvs(1, 0.5, size=1)
# Дословно : 'брось 3 монеты с шансом выпадания 25%, 10 раз'
binom.rvs(3, 0.25, size=10)

# Дословно : 'какой шанс того,что я получу 7 выйгрышей,если подбросить монету 10 раз с шансом 0.5'
binom.pmf(7, 10, 0.5)

# Дословно : 'какой шанс того,что я получу 7 или меньше выйгрышей,если подбросить монету 10 раз с шансом 0.5'
binom.cdf(7, 10, 0.5)

# Дословно : 'какой шанс того,что я получу больше 7 выйгрышей,если подбросить монету 10 раз с шансом 0.5'
1- binom.cdf(7,10,0.5)

--------------------------------
# Правило 68,95,99.7(3 std) в Normal Distribution 

from scipy.stats import norm
# Какой процент женщин ниже 154см 
# 161 - mean,7 - std 
norm.cdf(154, 161, 7)

# Какой процент женщин от 154см до 157см 
norm.cdf(157, 161, 7) - norm.cdf(154, 161, 7)

# Какой высоты 90% женщин ниже 
norm.ppf(0.9, 161, 7)

# Какой высоты 90% женщин выше или 10% женщин ниже
norm.ppf((1-0.9), 161, 7)

# Создаем 10 случайных чисел,которые распределены по нормальному закону  
norm.rvs(161, 7, size=10)

----------------------------------
# Пуасонновское распределение 
# Пример: если у нас в день помирает 20 кошек,то с какой вероятностью у нас умрет 5 кошек завтра 
# Тут у нас должен быть основная переменная 'L' которая отвечает 'сколько в день помирает'


from scipy.stats import poisson
# Какой шанс того,что умрет 5 кошек,если обычно умирает по 8
poisson.pmf(5, 8)


from scipy.stats import poisson
# Какой шанс того,что умрет 5 и меньше кошек,если обычно умирает 8
poisson.cdf(5, 8)


from scipy.stats import poisson
# 10 чисел в распределении Пуассона,при 'L' = 8
poisson.rvs(8, size=10)


--------------------------------
# Экспоненциальное распределение
# Шанс того,что завтра и послезавтра кошки не помрут 
# Также есть 'L' - отношение события ко времени  

from scipy.stats import expon
# Шанс того,что событие произойде за одну минуту,если половина события происходит за одну минуту 
expon.cdf(1, scale=0.5)

# Шанс того что событие произойдет от 1 до 3-й минуты 
expon.cdf(3, scale=0.5) - expon.cdf(1, scale=0.5)
-------------------------------
# Корреляция - только линейная связь 
# Плотим линию,которая показывает наклон корреляции 
import seaborn as sns
sns.lmplot(x="sleep_total", y="sleep_rem", data=msleep, ci=None)
plt.show()

# Вычисляем корреляцию
msleep['sleep_total'].corr(msleep['sleep_rem'])

# Чтобы бороться с тем что у нас данные 'пиздец,какие странные' или 'просто слишком большие значения по сравнению с другой осью',то используем:
np.log()
np.sqrt()
1/x 
# и различные конбинации 


# Не забывай,что есть скрытые факторы,которые влияют на корреляцию
# A/Б тестирование,плацебо,время 
